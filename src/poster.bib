@article{10.1145/3337794,
  author = {Thakur, Manas and Nandivada, V. Krishna},
  title = "{PYE: A Framework for Precise-Yet-Efficient Just-In-Time Analyses for Java Programs}",
  year = {2019},
  issue_date = {September 2019},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {41},
  number = {3},
  issn = {0164-0925},
  url = {https://doi.org/10.1145/3337794},
  doi = {10.1145/3337794},
  abstract = {Languages like Java and C# follow a two-step process of compilation: static compilation and just-in-time (JIT) compilation. As the time spent in JIT compilation gets added to the execution-time of the application, JIT compilers typically sacrifice the precision of program analyses for efficiency. The alternative of performing the analysis for the whole program statically ignores the analysis of libraries (available only at runtime), and thereby generates imprecise results. To address these issues, in this article, we propose a two-step (static+JIT) analysis framework called precise-yet-efficient (PYE) that helps generate precise analysis-results at runtime at a very low cost.PYE achieves the twin objectives of precision and performance during JIT compilation by using a two-pronged approach: (i)&nbsp;It performs expensive analyses during static compilation, while accounting for the unavailability of the runtime libraries by generating partial results, in terms of conditional values, for the input application. (ii)&nbsp;During JIT compilation, PYE resolves the conditions associated with these values, using the pre-computed conditional values for the libraries, to generate the final results. We have implemented the static and the runtime components of PYE in the Soot optimization framework and the OpenJDK HotSpot Server Compiler&nbsp;(C2), respectively. We demonstrate the usability of PYE by instantiating it to perform two context-, flow-, and field-sensitive heap-based analyses: (i)&nbsp;points-to analysis for null-dereference-check elimination; and (ii)&nbsp;escape analysis for synchronization elimination. We evaluate these instantiations against their corresponding state-of-the-art implementations in C2 over a wide range of benchmarks. The extensive evaluation results show that our strategy works quite well and fulfills both the promises it makes: enhanced precision while maintaining efficiency during JIT compilation.},
  journal = {ACM Trans. Program. Lang. Syst.},
  month = jul,
  articleno = {16},
  numpages = {37},
  keywords = {Java program analysis, precise and efficient program analysis}
}